// Author: ClÃ¡udio Gomes (TofuLynx)
// Project: emubayer
// License: GNU GPL Version 3 (https://www.gnu.org/licenses/gpl-3.0.en.html)

use super::*;

fn get_input_vector_even() -> Vec<u8> {
    // R->1 G->2 B->3
    // 8x8 image
    vec![
        1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,
        1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,
        1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,
        1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,
        1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,
        1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,
        1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,
        1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,
    ]
}

fn get_input_vector_odd() -> Vec<u8> {
    // R->1 G->2 B->3
    // 9x9 image
    vec![
        1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,
        1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,
        1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,
        1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,
        1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,
        1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,
        1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,
        1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,
        1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,
    ]
}

#[test]
fn test_image_extract_rggb_even() {
    let rgb_image = RgbImage {
        width: 8,
        height: 8,
        data: get_input_vector_even(),
        bit_depth: BitDepth::Eight,
    };

    let raw_image = rgb_image.to_raw(BayerPattern::RGGB);

    assert_eq!(raw_image.data, vec![
        1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8,
        2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8,
        1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8,
        2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8,
        1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8,
        2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8,
        1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8,
        2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8,
    ]);
}

#[test]
fn test_image_extract_rggb_odd() {
    let rgb_image = RgbImage {
        width: 9,
        height: 9,
        data: get_input_vector_odd(),
        bit_depth: BitDepth::Eight,
    };

    let raw_image = rgb_image.to_raw(BayerPattern::RGGB);

    assert_eq!(raw_image.data, vec![
        1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8,
        2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8,
        1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8,
        2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8,
        1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8,
        2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8,
        1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8,
        2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8,
    ]);
}

#[test]
fn test_image_extract_bggr_even() {
    let rgb_image = RgbImage {
        width: 8,
        height: 8,
        data: get_input_vector_even(),
        bit_depth: BitDepth::Eight,
    };

    let raw_image = rgb_image.to_raw(BayerPattern::BGGR);

    assert_eq!(raw_image.data, vec![
        3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8,
        2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8,
        3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8,
        2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8,
        3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8,
        2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8,
        3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8,
        2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8,
    ]);
}

#[test]
fn test_image_extract_bggr_odd() {
    let rgb_image = RgbImage {
        width: 9,
        height: 9,
        data: get_input_vector_odd(),
        bit_depth: BitDepth::Eight,
    };

    let raw_image = rgb_image.to_raw(BayerPattern::BGGR);

    assert_eq!(raw_image.data, vec![
        3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8,
        2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8,
        3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8,
        2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8,
        3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8,
        2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8,
        3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8,
        2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8,
    ]);
}

#[test]
fn test_image_extract_grbg_even() {
    let rgb_image = RgbImage {
        width: 8,
        height: 8,
        data: get_input_vector_even(),
        bit_depth: BitDepth::Eight,
    };

    let raw_image = rgb_image.to_raw(BayerPattern::GRBG);

    assert_eq!(raw_image.data, vec![
        2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8,
        3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8,
        2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8,
        3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8,
        2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8,
        3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8,
        2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8,
        3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8,
    ]);
}

#[test]
fn test_image_extract_grbg_odd() {
    let rgb_image = RgbImage {
        width: 9,
        height: 9,
        data: get_input_vector_odd(),
        bit_depth: BitDepth::Eight,
    };

    let raw_image = rgb_image.to_raw(BayerPattern::GRBG);

    assert_eq!(raw_image.data, vec![
        2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8,
        3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8,
        2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8,
        3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8,
        2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8,
        3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8,
        2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8,
        3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8,
    ]);
}

#[test]
fn test_image_extract_gbrg_even() {
    let rgb_image = RgbImage {
        width: 8,
        height: 8,
        data: get_input_vector_even(),
        bit_depth: BitDepth::Eight,
    };

    let raw_image = rgb_image.to_raw(BayerPattern::GBRG);

    assert_eq!(raw_image.data, vec![
        2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8,
        1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8,
        2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8,
        1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8,
        2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8,
        1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8,
        2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8,
        1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8,
    ]);
}

#[test]
fn test_image_extract_gbrg_odd() {
    let rgb_image = RgbImage {
        width: 9,
        height: 9,
        data: get_input_vector_odd(),
        bit_depth: BitDepth::Eight,
    };

    let raw_image = rgb_image.to_raw(BayerPattern::GBRG);

    assert_eq!(raw_image.data, vec![
        2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8,
        1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8,
        2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8,
        1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8,
        2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8,
        1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8,
        2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8, 2<<8, 3<<8,
        1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8, 1<<8, 2<<8,
    ]);
}